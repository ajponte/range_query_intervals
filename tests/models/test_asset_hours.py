"""
Starter file generated by Google Gemini.
"""

import pytest
from sqlalchemy import create_engine, Column, Integer, VARCHAR
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.types import TypeDecorator, Unicode


# Mocking the TSRANGE type for compatibility with SQLite
# Since SQLAlchemy's TSRANGE is PostgreSQL-specific, we'll store it as a string.
class MockTSRANGE(TypeDecorator):
    impl = Unicode
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        # Here we assume the value is a string or can be cast to one
        return value

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        # You could add logic here to parse the string back into a custom object
        return value

# Define the Base for the tests
Base = declarative_base()

# Re-define the AssetHours model using our mocked dependencies
class PartialInterval(Base):
    __tablename__ = 'partial_interval'

    id = Column(Integer, primary_key=True)
    label = Column(VARCHAR(16))
    open_interval = Column(MockTSRANGE, nullable=False)

# -------------------- Pytest Fixtures --------------------

@pytest.fixture(scope='session')
def setup_database():
    """
    Sets up an in-memory SQLite database for the test session.
    This fixture is scoped to the entire test session to avoid
    recreating the database for every test function.
    """
    engine = create_engine('sqlite:///:memory:')
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)

@pytest.fixture(scope='function')
def db_session(setup_database):
    """
    Creates a new database session for each test function.
    This ensures that each test runs with a clean state.
    It wraps each test in a transaction and rolls it back
    at the end, effectively cleaning up the database.
    """
    connection = setup_database.connect()
    transaction = connection.begin()
    Session = sessionmaker(bind=connection)
    session = Session()

    yield session

    session.close()
    transaction.rollback()
    connection.close()

# -------------------- Test Functions --------------------

def test_asset_hours_table_exists(setup_database):
    """
    Test that the 'store_hours' table was created successfully.
    """
    engine = setup_database
    with engine.connect() as connection:
        assert 'partial_interval' in engine.dialect.get_table_names(connection)

def test_create_and_retrieve_partial_interval(db_session):
    """
    Test the basic create and retrieve functionality of the model.
    """
    mock_infimum = 1
    mock_label = 'test'
    partial_interval = PartialInterval(
        open_interval=mock_infimum,
        label=mock_label
    )
    db_session.add(partial_interval)
    db_session.commit()

    retrieved_partial_interval = db_session.query(PartialInterval).filter_by(id=partial_interval.id).first()
    assert retrieved_partial_interval is not None
    assert int(retrieved_partial_interval.open_interval) == mock_infimum
    assert retrieved_partial_interval.label == mock_label

def test_nullable_constraints(db_session):
    """
    Test that required columns cannot be null.
    We expect a ValueError or similar exception from SQLAlchemy.
    """
    with pytest.raises(Exception):
        # Missing 'day' and 'open_interval'
        invalid_asset_hours = PartialInterval()
        db_session.add(invalid_asset_hours)
        db_session.commit()
