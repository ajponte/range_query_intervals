"""
Starter file generated by Google Gemini.
"""

import pytest
from sqlalchemy import create_engine, Column, Integer, Enum, String
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.types import TypeDecorator, Unicode
from enum import Enum as PyEnum

# Mocking the dependencies from the user's provided model
# In a real-world scenario, you would import these directly.
class CanonicalDay(PyEnum):
    MONDAY = "monday"
    TUESDAY = "tuesday"
    WEDNESDAY = "wednesday"
    THURSDAY = "thursday"
    FRIDAY = "friday"
    SATURDAY = "saturday"
    SUNDAY = "sunday"

# Mocking the TSRANGE type for compatibility with SQLite
# Since SQLAlchemy's TSRANGE is PostgreSQL-specific, we'll store it as a string
# for these tests. In a production test setup with PostgreSQL, you'd use the real TSRANGE.
class MockTSRANGE(TypeDecorator):
    impl = Unicode
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        # Here we assume the value is a string or can be cast to one
        return str(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        # You could add logic here to parse the string back into a custom object
        return value

# Define the Base for the tests
Base = declarative_base()

# Re-define the AssetHours model using our mocked dependencies
class AssetHours(Base):
    __tablename__ = 'store_hours'

    id = Column(Integer, primary_key=True)
    day = Column(Enum(CanonicalDay, name="canonical_day"), nullable=False)
    open_interval = Column(MockTSRANGE, nullable=False)

# -------------------- Pytest Fixtures --------------------

@pytest.fixture(scope='session')
def setup_database():
    """
    Sets up an in-memory SQLite database for the test session.
    This fixture is scoped to the entire test session to avoid
    recreating the database for every test function.
    """
    engine = create_engine('sqlite:///:memory:')
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)

@pytest.fixture(scope='function')
def db_session(setup_database):
    """
    Creates a new database session for each test function.
    This ensures that each test runs with a clean state.
    It wraps each test in a transaction and rolls it back
    at the end, effectively cleaning up the database.
    """
    connection = setup_database.connect()
    transaction = connection.begin()
    Session = sessionmaker(bind=connection)
    session = Session()

    yield session

    session.close()
    transaction.rollback()
    connection.close()

# -------------------- Test Functions --------------------

def test_asset_hours_table_exists(setup_database):
    """
    Test that the 'store_hours' table was created successfully.
    """
    engine = setup_database
    with engine.connect() as connection:
        assert 'store_hours' in engine.dialect.get_table_names(connection)

def test_create_and_retrieve_asset_hours(db_session):
    """
    Test the basic create and retrieve functionality of the model.
    """
    new_asset_hours = AssetHours(
        day=CanonicalDay.MONDAY,
        open_interval='09:00-17:00'
    )
    db_session.add(new_asset_hours)
    db_session.commit()

    retrieved_asset_hours = db_session.query(AssetHours).filter_by(id=new_asset_hours.id).first()
    assert retrieved_asset_hours is not None
    assert retrieved_asset_hours.day == CanonicalDay.MONDAY
    assert retrieved_asset_hours.open_interval == '09:00-17:00'

def test_nullable_constraints(db_session):
    """
    Test that required columns cannot be null.
    We expect a ValueError or similar exception from SQLAlchemy.
    """
    with pytest.raises(Exception):
        # Missing 'day' and 'open_interval'
        invalid_asset_hours = AssetHours()
        db_session.add(invalid_asset_hours)
        db_session.commit()

def test_enum_column_type(db_session):
    """
    Test that the 'day' column correctly stores and retrieves an Enum value.
    """
    new_asset_hours = AssetHours(
        day=CanonicalDay.WEDNESDAY,
        open_interval='10:00-18:00'
    )
    db_session.add(new_asset_hours)
    db_session.commit()

    retrieved_asset_hours = db_session.query(AssetHours).filter_by(day=CanonicalDay.WEDNESDAY).first()
    assert retrieved_asset_hours is not None
    assert isinstance(retrieved_asset_hours.day, CanonicalDay)
    assert retrieved_asset_hours.day.value == 'wednesday'

def test_create_with_test_double_value(db_session):
    # A simple string serves as the test double for the TSRANGE value
    test_double_interval = "12:00-20:00"

    new_asset_hours = AssetHours(
        day=CanonicalDay.FRIDAY,
        open_interval=test_double_interval
    )
    db_session.add(new_asset_hours)
    db_session.commit()

    retrieved_asset_hours = db_session.query(AssetHours).filter_by(day=CanonicalDay.FRIDAY).first()
    assert retrieved_asset_hours.open_interval == test_double_interval
